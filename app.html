// -------- Utility: Haversine distance in KM --------
function haversineKm(a, b) {
  const toRad = (x) => (x * Math.PI) / 180;
  const R = 6371; // km
  const dLat = toRad(b.lat - a.lat);
  const dLon = toRad(b.lon - a.lon);
  const lat1 = toRad(a.lat);
  const lat2 = toRad(b.lat);
  const h =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
  return 2 * R * Math.asin(Math.sqrt(h));
}

// -------- Globals --------
let map, userMarker, userCircle;
let soilData = [];
let markersLayer = L.layerGroup();
let routeLine;

// Soil types generally better for brick-making (you can adjust)
const DEFAULT_GOOD_TYPES = ["Alluvial", "Clay", "Clay-Loam", "Loam"];

// -------- Map Init --------
function initMap() {
  map = L.map("map").setView({ lat: 22.9734, lon: 78.6569 }, 5); // India center
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "© OpenStreetMap contributors",
  }).addTo(map);

  // Add geocoder (search box)
  L.Control.geocoder({
    defaultMarkGeocode: false,
  })
    .on("markgeocode", function (e) {
      const c = e.geocode.center;
      setUserLocation(c.lat, c.lng, "📍 Selected place");
      map.setView(c, 12);
    })
    .addTo(map);

  markersLayer.addTo(map);
}

function setUserLocation(lat, lon, label = "📍 You are here") {
  if (userMarker) map.removeLayer(userMarker);
  if (userCircle) map.removeLayer(userCircle);

  userMarker = L.marker([lat, lon], { title: "You" }).bindPopup(label);
  userCircle = L.circle([lat, lon], { radius: 200 }); // 200 m visual circle
  userMarker.addTo(map).openPopup();
  userCircle.addTo(map);
}

async function loadSoils() {
  try {
    const res = await fetch("data/soils.json");
    soilData = await res.json();
  } catch (e) {
    alert("Failed to load soils.json. If running locally, use a local server.");
    console.error(e);
  }
}

function renderSoilMarkers(list) {
  markersLayer.clearLayers();
  list.forEach((loc, idx) => {
    const m = L.marker([loc.lat, loc.lon]).bindPopup(
      `<b>${idx + 1}. ${loc.name}</b><br/>
       Soil: ${loc.soilType} | Suitability: ${loc.suitability}/100<br/>
       Distance: ${loc._distanceKm.toFixed(1)} km<br/>
       Notes: ${loc.notes || "—"}`
    );
    m.on("click", () => {
      if (routeLine) map.removeLayer(routeLine);
      if (userMarker) {
        routeLine = L.polyline(
          [
            [userMarker.getLatLng().lat, userMarker.getLatLng().lng],
            [loc.lat, loc.lon],
          ],
          { weight: 3, opacity: 0.7 }
        ).addTo(map);
      }
    });
    markersLayer.addLayer(m);
  });
}

function renderResultsList(list) {
  const ol = document.getElementById("results");
  ol.innerHTML = "";
  list.forEach((loc, i) => {
    const li = document.createElement("li");
    li.innerHTML = `<strong>${i + 1}. ${loc.name}</strong>
      <span class="badge">${loc.soilType}</span>
      <div class="distance">${loc._distanceKm.toFixed(1)} km • Suitability ${loc.suitability}/100</div>`;
    li.addEventListener("click", () => {
      map.setView([loc.lat, loc.lon], 12);
      // open popup for this marker
      markersLayer.eachLayer((m) => {
        const ml = m.getLatLng();
        if (ml.lat === loc.lat && ml.lng === loc.lon) {
          m.openPopup();
        }
      });
    });
    ol.appendChild(li);
  });
}

function getSelectedSoilTypes() {
  const sel = document.getElementById("soilTypeFilter");
  const selected = Array.from(sel.options)
    .filter((o) => o.selected)
    .map((o) => o.value);
  return selected.length ? selected : DEFAULT_GOOD_TYPES;
}

function findBestNearby(userLat, userLon) {
  const radiusKm = Number(document.getElementById("radiusInput").value) || 200;
  const allowedTypes = getSelectedSoilTypes();

  // Compute distance
  const withDist = soilData.map((s) => {
    const d = haversineKm({ lat: userLat, lon: userLon }, s);
    return { ...s, _distanceKm: d };
  });

  // Filter by radius and soil type, then sort by:
  // 1) higher suitability
  // 2) then nearer distance
  const filtered = withDist
    .filter(
      (s) =>
        s._distanceKm <= radiusKm &&
        (allowedTypes.includes(s.soilType) || allowedTypes.includes("All"))
    )
    .sort((a, b) => {
      if (b.suitability !== a.suitability)
        return b.suitability - a.suitability;
      return a._distanceKm - b._distanceKm;
    })
    .slice(0, 20); // show top 20

  // Show on map + sidebar
  renderSoilMarkers(filtered);
  renderResultsList(filtered);

  if (filtered.length) {
    const group = L.featureGroup(
      filtered.map((f) => L.marker([f.lat, f.lon]))
    );
    if (userMarker) group.addLayer(userMarker);
    map.fitBounds(group.getBounds().pad(0.2));
  } else {
    alert("No suitable locations found within the selected radius/filters.");
  }
}

// -------- Event wiring --------
document.addEventListener("DOMContentLoaded", async () => {
  initMap();
  await loadSoils();

  // Default: try geolocation once at start
  if ("geolocation" in navigator) {
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        setUserLocation(latitude, longitude);
        map.setView([latitude, longitude], 12);
      },
      () => {
        // If blocked, keep map at default; user can search manually.
        console.warn("Geolocation denied. Use the search box or button.");
      },
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 }
    );
  }

  // Button: Use My Location
  document.getElementById("locateBtn").addEventListener("click", () => {
    if (!("geolocation" in navigator)) {
      return alert("Geolocation not supported in this browser.");
    }
    navigator.geolocation.getCurrentPosition(
      (pos) => {
        const { latitude, longitude } = pos.coords;
        setUserLocation(latitude, longitude);
        map.setView([latitude, longitude], 12);
      },
      (err) => alert("Couldn't get your location: " + err.message),
      { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 }
    );
  });

  // Button: Find Best Nearby
  document.getElementById("findBtn").addEventListener("click", () => {
    if (!userMarker) {
      return alert(
        "Set your location first (Use My Location or search a place on the map)."
      );
    }
    const p = userMarker.getLatLng();
    findBestNearby(p.lat, p.lng);
  });
});
